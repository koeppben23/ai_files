name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:

  # ----------------------------------
  # Job 1: Installer Tests (Cross-OS)
  # ----------------------------------
  test-installer:
    name: Test Installer on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}

    env:
      PYTHONIOENCODING: utf-8
      PYTHONUTF8: "1"

    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        python-version: ['3.9', '3.10', '3.11', '3.12']

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Prepare temp config root
        shell: bash
        run: |
          echo "CONFIG_ROOT=$RUNNER_TEMP/opencode-config" >> $GITHUB_ENV

      - name: Dry Run
        shell: bash
        run: |
          python -X utf8 install.py --dry-run --config-root "$CONFIG_ROOT"

      - name: Fresh Install
        shell: bash
        run: |
          python -X utf8 install.py --force --no-backup --config-root "$CONFIG_ROOT"

      - name: Manifest Roundtrip (listed files exist + no traversal)
        shell: bash
        run: |
          python - <<'PY'
          from pathlib import Path
          import json, os, hashlib, re

          root = Path(os.environ["CONFIG_ROOT"])
          commands = root / "commands"
          manifest_path = commands / "INSTALL_MANIFEST.json"

          assert manifest_path.exists(), f"Missing manifest: {manifest_path}"
          data = json.loads(manifest_path.read_text(encoding="utf-8"))
          assert "files" in data, "Manifest missing 'files' key"

          files = data["files"]
          assert isinstance(files, (list, dict)), f"Manifest 'files' must be list or dict, got: {type(files).__name__}"

          base = commands.resolve()
          seen = set()
          count = 0
          
          def sha256_file(p: Path) -> str:
            h = hashlib.sha256()
            with p.open("rb") as f:
              for chunk in iter(lambda: f.read(1024 * 1024), b""):
                h.update(chunk)
            return h.hexdigest()

          def looks_like_sha256(s: object) -> bool:
            return isinstance(s, str) and bool(re.fullmatch(r"[0-9a-fA-F]{64}", s))

          def assert_under_base(p: Path, label: str) -> None:
            p = p.resolve()
            try:
              p.relative_to(base)
            except ValueError:
              raise AssertionError(f"{label} escapes commands dir: {p} (base={base})")
            assert p.exists(), f"{label} missing on disk: {p}"

          # Case A: files is dict[str, ...] where keys are paths (relative or absolute)
          if isinstance(files, dict):
            items = list(files.keys())
            assert items, "Manifest 'files' is empty"
            for entry in items:
              assert isinstance(entry, str) and entry.strip(), f"Invalid manifest key: {entry!r}"
              assert entry not in seen, f"Duplicate manifest entry: {entry}"
              seen.add(entry)

              p = Path(entry)
              target = p if p.is_absolute() else (commands / p)
              assert_under_base(target, "Manifest file")
              count += 1

          # Case B: files is list[...] ‚Äî either list[str] or list[dict]
          else:
            assert files, "Manifest 'files' is empty"
            for entry in files:
              # list[str]
              if isinstance(entry, str):
                rel = entry
                assert rel.strip(), f"Invalid manifest entry: {rel!r}"
                assert rel not in seen, f"Duplicate manifest entry: {rel}"
                seen.add(rel)

                p = Path(rel)
                # Prevent traversal for relative form
                assert not p.is_absolute(), f"Absolute path in string manifest entry: {rel}"
                assert ".." not in p.parts, f"Path traversal in manifest entry: {rel}"

                target = (commands / p)
                assert_under_base(target, "Manifest file")
                count += 1
                continue

              # list[dict] with at least dst
              if isinstance(entry, dict):
                assert "dst" in entry, f"Manifest dict entry missing 'dst': {entry}"
                dst = entry["dst"]
                assert isinstance(dst, str) and dst.strip(), f"Invalid dst in manifest entry: {dst!r}"

                # Use dst as unique key (stable)
                if dst in seen:
                  raise AssertionError(f"Duplicate manifest dst: {dst}")
                seen.add(dst)

                target = Path(dst)
                # dst may be absolute (your current case). If relative, interpret as under commands.
                target = target if target.is_absolute() else (commands / target)
                assert_under_base(target, "Manifest dst")
                
                # Optional but recommended: verify sha256 when present
                expected = entry.get("sha256")
                if looks_like_sha256(expected):
                  got = sha256_file(target)
                  if got.lower() != expected.lower():
                    raise AssertionError(f"SHA256 mismatch for {target}: expected={expected} got={got}")
                
                count += 1
                continue

              raise AssertionError(f"Invalid manifest list entry type: {type(entry).__name__}: {entry!r}")

          print(f"‚úÖ Manifest roundtrip OK ({count} entries)")
          PY

      - name: Verify Files
        shell: bash
        run: |
          python - <<'PY'
          from pathlib import Path
          import json, os, hashlib, re

          root = Path(os.environ["CONFIG_ROOT"])
          manifest = root / "commands" / "INSTALL_MANIFEST.json"
          paths_file = root / "commands" / "governance.paths.json"

          critical = [
              root / "commands" / "master.md",
              root / "commands" / "rules.md",
              root / "commands" / "start.md",
              manifest,
              paths_file,
          ]

          for f in critical:
              assert f.exists(), f"Missing: {f}"

          with open(manifest, encoding="utf-8") as fh:
              data = json.load(fh)
              assert "files" in data, "Manifest missing 'files' key"

          with open(paths_file, encoding="utf-8") as fh:
              p = json.load(fh)

          assert "paths" in p and isinstance(p["paths"], dict), "governance.paths.json missing 'paths' object"

          required_paths = ["configRoot", "commandsHome", "profilesHome", "diagnosticsHome"]
          missing = [k for k in required_paths if k not in p["paths"]]
          assert not missing, f"governance.paths.json missing keys: {missing}"
          
          commands_home = p["paths"]["commandsHome"]
          diagnostics_home = p["paths"]["diagnosticsHome"]

          # tolerate slash style on Windows
          dh = diagnostics_home.replace("\\", "/")
          ch = commands_home.replace("\\", "/")
          dh = dh.rstrip("/")
          ch = ch.rstrip("/")

          assert dh == f"{ch}/diagnostics" or dh.endswith("/diagnostics"), (
              f"diagnosticsHome unexpected: {diagnostics_home} (commandsHome={commands_home})"
          )

          for k in required_paths:
              v = p["paths"][k]
              assert isinstance(v, str) and v.strip(), f"Invalid path value for {k}: {v!r}"

          print("‚úÖ Verification OK (files + manifest + governance.paths.json)")
          PY
          
      - name: Capture canonical JSON hashes (before reinstall)
        shell: bash
        run: |
          python - <<'PY'
          from pathlib import Path
          import json, os, hashlib

          root = Path(os.environ["CONFIG_ROOT"])
          manifest = root / "commands" / "INSTALL_MANIFEST.json"
          paths_file = root / "commands" / "governance.paths.json"

          def canon_sha256(path: Path) -> str:
            obj = json.loads(path.read_text(encoding="utf-8"))
            canon = json.dumps(obj, sort_keys=True, ensure_ascii=False, separators=(",", ":"))
            return hashlib.sha256(canon.encode("utf-8")).hexdigest()

          def manifest_fingerprint_sha256(path: Path) -> str:
            obj = json.loads(path.read_text(encoding="utf-8"))
            base = path.parent.resolve()  # .../commands
            files = obj.get("files")
            if not isinstance(files, list):
              raise AssertionError(f"Expected manifest['files'] as list, got: {type(files).__name__}")

            # Build stable mapping dst -> sha256 (only where dst exists)
            rows = []
            for e in files:
              if isinstance(e, dict) and isinstance(e.get("dst"), str):
                dst_raw = e["dst"]
                dst_path = Path(dst_raw)
                # normalize to stable relative identity when possible
                try:
                  dst_norm = dst_path.resolve().relative_to(base).as_posix()
                except Exception:
                  # fallback: best-effort normalize slashes
                  dst_norm = str(dst_raw).replace("\\", "/")
                sha = e.get("sha256") if isinstance(e.get("sha256"), str) else ""

                # Ignore SHA for self-referential / run-variant artifacts
                # Keep dst in fingerprint so drift is still detected.
                dst_name = Path(dst_raw).name
                if dst_name == "INSTALL_MANIFEST.json":
                  sha = ""

                rows.append((dst_norm, sha))
              elif isinstance(e, str):
                # legacy form: treat string as dst-ish
                rows.append((str(e).replace("\\", "/"), ""))
              else:
                raise AssertionError(f"Unexpected manifest entry: {e!r}")

            rows.sort()
            canon = json.dumps(rows, ensure_ascii=False, separators=(",", ":"))
            return hashlib.sha256(canon.encode("utf-8")).hexdigest()

          m_hash = manifest_fingerprint_sha256(manifest)
          p_hash = canon_sha256(paths_file)

          env_path = os.environ["GITHUB_ENV"]
          with open(env_path, "a", encoding="utf-8") as f:
            f.write(f"MANIFEST_FINGERPRINT_SHA256={m_hash}\n")
            f.write(f"CANON_PATHS_SHA256={p_hash}\n")

          print("üìå Canonical JSON hashes captured")
          print("  manifest:", m_hash)
          print("  paths:   ", p_hash)
          PY

      - name: Reinstall (Idempotency)
        shell: bash
        run: |
          python -X utf8 install.py --force --no-backup --config-root "$CONFIG_ROOT"

      - name: Verify Files (after Reinstall)
        shell: bash
        run: |
          python - <<'PY'
          from pathlib import Path
          import json, os, hashlib, re

          root = Path(os.environ["CONFIG_ROOT"])
          manifest = root / "commands" / "INSTALL_MANIFEST.json"
          paths_file = root / "commands" / "governance.paths.json"

          critical = [
              root / "commands" / "master.md",
              root / "commands" / "rules.md",
              root / "commands" / "start.md",
              manifest,
              paths_file,
          ]

          for f in critical:
              assert f.exists(), f"Missing: {f}"

          with open(manifest, encoding="utf-8") as fh:
              data = json.load(fh)
              assert "files" in data, "Manifest missing 'files' key"

          with open(paths_file, encoding="utf-8") as fh:
              p = json.load(fh)

          assert "paths" in p and isinstance(p["paths"], dict), "governance.paths.json missing 'paths' object"

          required_paths = ["configRoot", "commandsHome", "profilesHome", "diagnosticsHome"]
          missing = [k for k in required_paths if k not in p["paths"]]
          assert not missing, f"governance.paths.json missing keys: {missing}"

          commands_home = p["paths"]["commandsHome"]
          diagnostics_home = p["paths"]["diagnosticsHome"]

          # tolerate slash style on Windows
          dh = diagnostics_home.replace("\\", "/")
          ch = commands_home.replace("\\", "/")
          dh = dh.rstrip("/")
          ch = ch.rstrip("/")

          assert dh == f"{ch}/diagnostics" or dh.endswith("/diagnostics"), (
              f"diagnosticsHome unexpected: {diagnostics_home} (commandsHome={commands_home})"
          )

          for k in required_paths:
              v = p["paths"][k]
              assert isinstance(v, str) and v.strip(), f"Invalid path value for {k}: {v!r}"

          print("‚úÖ Verification OK after reinstall")
          PY

      - name: Verify canonical JSON hashes (after reinstall)
        shell: bash
        run: |
          python - <<'PY'
          from pathlib import Path
          import json, os, hashlib

          root = Path(os.environ["CONFIG_ROOT"])
          manifest = root / "commands" / "INSTALL_MANIFEST.json"
          paths_file = root / "commands" / "governance.paths.json"

          def canon_sha256(path: Path) -> str:
            obj = json.loads(path.read_text(encoding="utf-8"))
            canon = json.dumps(obj, sort_keys=True, ensure_ascii=False, separators=(",", ":"))
            return hashlib.sha256(canon.encode("utf-8")).hexdigest()

          def manifest_fingerprint_sha256(path: Path) -> str:
            obj = json.loads(path.read_text(encoding="utf-8"))
            base = path.parent.resolve()
            files = obj.get("files")
            if not isinstance(files, list):
              raise AssertionError(f"Expected manifest['files'] as list, got: {type(files).__name__}")

            rows = []
            for e in files:
              if isinstance(e, dict) and isinstance(e.get("dst"), str):
                dst_raw = e["dst"]
                dst_path = Path(dst_raw)
                try:
                  dst_norm = dst_path.resolve().relative_to(base).as_posix()
                except Exception:
                  dst_norm = str(dst_raw).replace("\\", "/")
                sha = e.get("sha256") if isinstance(e.get("sha256"), str) else ""

                dst_name = Path(dst_raw).name
                if dst_name == "INSTALL_MANIFEST.json":
                  sha = ""

                rows.append((dst_norm, sha))
              elif isinstance(e, str):
                rows.append((str(e).replace("\\", "/"), ""))
              else:
                raise AssertionError(f"Unexpected manifest entry: {e!r}")

            rows.sort()
            canon = json.dumps(rows, ensure_ascii=False, separators=(",", ":"))
            return hashlib.sha256(canon.encode("utf-8")).hexdigest()

          before_m = os.environ.get("MANIFEST_FINGERPRINT_SHA256")
          before_p = os.environ.get("CANON_PATHS_SHA256")
          assert before_m and before_p, "Missing captured canonical hashes from previous step"

          after_m = manifest_fingerprint_sha256(manifest)
          after_p = canon_sha256(paths_file)

          if after_m != before_m:
            # Debug: show which (dst, sha) pairs differ (top 25)
            def rows_for_debug(path: Path):
              obj = json.loads(path.read_text(encoding="utf-8"))
              rows = []
              for e in obj.get("files", []):
                if isinstance(e, dict) and isinstance(e.get("dst"), str):
                  dst = e["dst"]
                  sha = e.get("sha256") if isinstance(e.get("sha256"), str) else ""
                  if Path(dst).name == "INSTALL_MANIFEST.json":
                    sha = ""
                  rows.append((dst, sha))
                elif isinstance(e, str):
                  rows.append((e, ""))
              return sorted(rows)

            after_rows = rows_for_debug(manifest)  # manifest is already "after"
            # We can't reconstruct before_rows from disk (it was overwritten),
            # but we can at least print the after rows to help identify run-variant entries.
            print("‚ö†Ô∏è Manifest fingerprint mismatch. Showing AFTER rows (first 25):")
            for r in after_rows[:25]:
              print("  ", r)
            raise AssertionError(f"Manifest fingerprint changed after reinstall: before={before_m} after={after_m}")

          assert after_p == before_p, f"Paths canonical JSON changed after reinstall: before={before_p} after={after_p}"

          print("‚úÖ Canonical JSON determinism OK (manifest + governance.paths.json)")
          PY

      - name: Uninstall
        shell: bash
        run: |
          python -X utf8 install.py --uninstall --force --config-root "$CONFIG_ROOT"

      - name: Verify Uninstall Cleanliness
        shell: bash
        run: |
          python - <<'PY'
          from pathlib import Path
          import os

          root = Path(os.environ["CONFIG_ROOT"])
          commands = root / "commands"

          # These MUST be gone after uninstall
          must_be_gone = [
              commands / "master.md",
              commands / "rules.md",
              commands / "start.md",
              commands / "INSTALL_MANIFEST.json",
              commands / "governance.paths.json",
          ]

          still_there = [str(p) for p in must_be_gone if p.exists()]
          assert not still_there, f"Uninstall left artifacts behind: {still_there}"

          # Optional: tolerate config root existing, but ensure commands dir is gone or empty
          if commands.exists():
              leftovers = [p.name for p in commands.rglob("*") if p.is_file()]
              assert not leftovers, f"Commands dir not empty after uninstall: {leftovers[:25]}"

          print("‚úÖ Uninstall cleanliness OK")
          PY

  # ----------------------------------
  # Job 2: Governance Validation
  # ----------------------------------
  validate-governance:
    name: Validate Governance Files
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Required Files
        shell: bash
        run: |
          python - <<'PY'
          from pathlib import Path

          required = [
              "master.md",
              "rules.md",
              "start.md",
              "SESSION_STATE_SCHEMA.md",
          ]

          missing = [f for f in required if not Path(f).exists()]

          if missing:
              raise SystemExit(f"Missing: {missing}")

          print("‚úÖ Required files OK")
          PY

      - name: BLOCKED Consistency
        shell: bash
        run: |
          python - <<'PY'
          import re
          from pathlib import Path

          schema = Path("SESSION_STATE_SCHEMA.md").read_text(encoding="utf-8")
          master = Path("master.md").read_text(encoding="utf-8")

          s = set(re.findall(r'BLOCKED-[A-Z-]+', schema))
          m = set(re.findall(r'BLOCKED-[A-Z-]+', master))

          diff = s - m

          if diff:
              raise SystemExit(f"Missing in master: {diff}")

          print("‚úÖ BLOCKED consistency OK")
          PY

  # ----------------------------------
  # Job 3: Release Gate
  # ----------------------------------
  release-readiness:
    name: Release Readiness
    needs: [test-installer, validate-governance]
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Check Version
        shell: bash
        run: |
          python - <<'PY'
          import re
          from pathlib import Path

          text = Path("install.py").read_text()

          m = re.search(r'VERSION\s*=\s*"([^"]+)"', text)

          if not m:
              raise SystemExit("No VERSION found")

          print("VERSION:", m.group(1))
          PY

      - name: Summary
        run: |
          echo "## Release Check" >> $GITHUB_STEP_SUMMARY
          echo "- Installer OK" >> $GITHUB_STEP_SUMMARY
          echo "- Governance OK" >> $GITHUB_STEP_SUMMARY
          echo "**Status: READY üöÄ**" >> $GITHUB_STEP_SUMMARY
