name: Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      tag:
        description: "Existing release tag (vX.Y.Z)"
        required: true
      draft:
        description: "Create draft release"
        required: true
        type: boolean
        default: false
      prerelease:
        description: "Mark release as prerelease"
        required: true
        type: boolean
        default: false

permissions:
  contents: write
  id-token: write
  attestations: write

concurrency:
  group: release-${{ github.event_name == 'push' && github.ref_name || github.event.inputs.tag }}
  cancel-in-progress: false

jobs:
  publish:
    name: Build and Publish Release
    runs-on: ubuntu-latest
    env:
      PYTHONUTF8: "1"
      PYTHONIOENCODING: utf-8

    steps:
      - name: Resolve release tag
        id: release_tag
        run: |
          set -euo pipefail
          if [[ "${GITHUB_EVENT_NAME}" == "push" ]]; then
            tag="${GITHUB_REF_NAME}"
          else
            tag="${{ github.event.inputs.tag }}"
          fi
          if [[ ! "${tag}" =~ ^v([0-9]+\.[0-9]+\.[0-9]+([-.+][0-9A-Za-z.-]+)?)$ ]]; then
            echo "BLOCKED: release tag must match v<semver>; got ${tag}" >&2
            exit 1
          fi
          echo "tag=${tag}" >> "$GITHUB_OUTPUT"
          echo "version=${BASH_REMATCH[1]}" >> "$GITHUB_OUTPUT"

      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
        with:
          ref: ${{ steps.release_tag.outputs.tag }}
          fetch-depth: 0

      - uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5
        with:
          python-version: "3.11"

      - name: Install cosign
        uses: sigstore/cosign-installer@398d4b0eeef1380460a10c8013a76f728fb906ac # v3

      - name: Validate tag/master version consistency
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import re
          import sys
          from pathlib import Path

          expected = "${{ steps.release_tag.outputs.version }}"
          head = "\n".join(Path("master.md").read_text(encoding="utf-8").splitlines()[:80])
          m = re.search(
              r"Governance-Version:\s*([0-9]+\.[0-9]+\.[0-9]+(?:[-+][0-9A-Za-z.-]+)?)",
              head,
              flags=re.IGNORECASE | re.MULTILINE,
          )
          if not m:
              print("BLOCKED: Governance-Version missing in master.md", file=sys.stderr)
              raise SystemExit(1)
          observed = m.group(1)
          if observed != expected:
              print(f"BLOCKED: tag/master mismatch (tag={expected}, master={observed})", file=sys.stderr)
              raise SystemExit(1)
          PY

      - name: Install test dependencies
        run: |
          python3 -m pip install --upgrade pip
          python3 -m pip install pytest

      - name: Run release readiness gates
        run: |
          set -euo pipefail
          python3 scripts/governance_lint.py
          pytest -q -m release
          pytest -q -m build

      - name: Build release artifacts
        run: |
          set -euo pipefail
          python3 scripts/build.py --out-dir dist --formats zip,tar.gz
          python3 scripts/build_customer_install_bundle.py --dist-dir dist

      - name: Build release notes from changelog
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import re
          from pathlib import Path

          version = "${{ steps.release_tag.outputs.version }}"
          changelog = Path("CHANGELOG.md").read_text(encoding="utf-8")
          header = re.search(rf"^## \[{re.escape(version)}\]\s*-.*$", changelog, flags=re.MULTILINE)
          if not header:
              Path("dist/RELEASE_NOTES.md").write_text(
                  f"Release v{version}\n\nNo changelog section found for this version.\n",
                  encoding="utf-8",
              )
              raise SystemExit(0)

          body_start = header.start()
          remaining = changelog[header.end():]
          nxt = re.search(r"^## \[[^\]]+\]\s*-.*$", remaining, flags=re.MULTILINE)
          body_end = header.end() + (nxt.start() if nxt else len(remaining))
          notes = changelog[body_start:body_end].strip() + "\n"
          Path("dist/RELEASE_NOTES.md").write_text(notes, encoding="utf-8")
          PY

      - name: Verify expected release files
        run: |
          set -euo pipefail
          version="${{ steps.release_tag.outputs.version }}"
          test -f "dist/governance-${version}.zip"
          test -f "dist/governance-${version}.tar.gz"
          test -f "dist/SHA256SUMS.txt"
          test -f "dist/verification-report.json"
          test -f "dist/customer-install-bundle-v1.zip"
          test -f "dist/customer-install-bundle-v1.SHA256"
          test -f "dist/RELEASE_NOTES.md"

      - name: Generate SBOM for governance zip
        uses: anchore/sbom-action@28d71544de8eaf1b958d335707167c5f783590ad # v0
        with:
          path: dist/governance-${{ steps.release_tag.outputs.version }}.zip
          format: spdx-json
          output-file: dist/governance-${{ steps.release_tag.outputs.version }}.zip.spdx.json

      - name: Generate SBOM for customer bundle zip
        uses: anchore/sbom-action@28d71544de8eaf1b958d335707167c5f783590ad # v0
        with:
          path: dist/customer-install-bundle-v1.zip
          format: spdx-json
          output-file: dist/customer-install-bundle-v1.zip.spdx.json

      - name: Verify expected SBOM files
        run: |
          set -euo pipefail
          version="${{ steps.release_tag.outputs.version }}"
          test -f "dist/governance-${version}.zip.spdx.json"
          test -f "dist/customer-install-bundle-v1.zip.spdx.json"

      - name: Attest build provenance for governance zip
        uses: actions/attest-build-provenance@e8998f949152b193b063cb0ec769d69d929409be # v2
        with:
          subject-path: dist/governance-${{ steps.release_tag.outputs.version }}.zip

      - name: Attest build provenance for customer bundle zip
        uses: actions/attest-build-provenance@e8998f949152b193b063cb0ec769d69d929409be # v2
        with:
          subject-path: dist/customer-install-bundle-v1.zip

      - name: Attest SBOM for governance zip
        uses: actions/attest-sbom@bd218ad0dbcb3e146bd073d1d9c6d78e08aa8a0b # v2
        with:
          subject-path: dist/governance-${{ steps.release_tag.outputs.version }}.zip
          sbom-path: dist/governance-${{ steps.release_tag.outputs.version }}.zip.spdx.json

      - name: Attest SBOM for customer bundle zip
        uses: actions/attest-sbom@bd218ad0dbcb3e146bd073d1d9c6d78e08aa8a0b # v2
        with:
          subject-path: dist/customer-install-bundle-v1.zip
          sbom-path: dist/customer-install-bundle-v1.zip.spdx.json

      - name: Sign release assets (cosign keyless)
        run: |
          set -euo pipefail
          version="${{ steps.release_tag.outputs.version }}"
          artifacts=(
            "dist/governance-${version}.zip"
            "dist/governance-${version}.tar.gz"
            "dist/SHA256SUMS.txt"
            "dist/verification-report.json"
            "dist/customer-install-bundle-v1.zip"
            "dist/customer-install-bundle-v1.SHA256"
          )
          for artifact in "${artifacts[@]}"; do
            cosign sign-blob --yes --bundle "${artifact}.sigstore.json" "${artifact}"
          done

      - name: Verify signature identity constraints
        run: |
          set -euo pipefail
          version="${{ steps.release_tag.outputs.version }}"
          issuer="https://token.actions.githubusercontent.com"
          identity_re="^https://github\\.com/${GITHUB_REPOSITORY}/\\.github/workflows/release\\.yml@refs/tags/v[0-9]+\\.[0-9]+\\.[0-9]+([-.+][0-9A-Za-z.-]+)?$"
          artifacts=(
            "dist/governance-${version}.zip"
            "dist/governance-${version}.tar.gz"
            "dist/SHA256SUMS.txt"
            "dist/verification-report.json"
            "dist/customer-install-bundle-v1.zip"
            "dist/customer-install-bundle-v1.SHA256"
          )
          for artifact in "${artifacts[@]}"; do
            bundle="${artifact}.sigstore.json"
            test -f "${bundle}"
            cosign verify-blob \
              --bundle "${bundle}" \
              --certificate-oidc-issuer "${issuer}" \
              --certificate-identity-regexp "${identity_re}" \
              "${artifact}" >/dev/null
          done

      - name: Publish GitHub Release
        env:
          GH_TOKEN: ${{ github.token }}
          DRAFT: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.draft || 'false' }}
          PRERELEASE: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.prerelease || 'false' }}
        run: |
          set -euo pipefail
          tag="${{ steps.release_tag.outputs.tag }}"
          version="${{ steps.release_tag.outputs.version }}"
          args=()
          if [[ "${DRAFT}" == "true" ]]; then
            args+=(--draft)
          fi
          if [[ "${PRERELEASE}" == "true" ]]; then
            args+=(--prerelease)
          fi

          if gh release view "${tag}" >/dev/null 2>&1; then
            gh release upload "${tag}" \
              "dist/governance-${version}.zip" \
              "dist/governance-${version}.zip.sigstore.json" \
              "dist/governance-${version}.zip.spdx.json" \
              "dist/governance-${version}.tar.gz" \
              "dist/governance-${version}.tar.gz.sigstore.json" \
              "dist/SHA256SUMS.txt" \
              "dist/SHA256SUMS.txt.sigstore.json" \
              "dist/verification-report.json" \
              "dist/verification-report.json.sigstore.json" \
              "dist/customer-install-bundle-v1.zip" \
              "dist/customer-install-bundle-v1.zip.spdx.json" \
              "dist/customer-install-bundle-v1.SHA256" \
              "dist/customer-install-bundle-v1.zip.sigstore.json" \
              "dist/customer-install-bundle-v1.SHA256.sigstore.json" \
              --clobber
          else
            gh release create "${tag}" \
              "dist/governance-${version}.zip" \
              "dist/governance-${version}.zip.sigstore.json" \
              "dist/governance-${version}.zip.spdx.json" \
              "dist/governance-${version}.tar.gz" \
              "dist/governance-${version}.tar.gz.sigstore.json" \
              "dist/SHA256SUMS.txt" \
              "dist/SHA256SUMS.txt.sigstore.json" \
              "dist/verification-report.json" \
              "dist/verification-report.json.sigstore.json" \
              "dist/customer-install-bundle-v1.zip" \
              "dist/customer-install-bundle-v1.zip.spdx.json" \
              "dist/customer-install-bundle-v1.SHA256" \
              "dist/customer-install-bundle-v1.zip.sigstore.json" \
              "dist/customer-install-bundle-v1.SHA256.sigstore.json" \
              --title "Release ${tag}" \
              --notes-file "dist/RELEASE_NOTES.md" \
              "${args[@]}"
          fi

      - name: Upload workflow artifacts
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: release-dist-${{ steps.release_tag.outputs.tag }}
          path: dist/*
